#' Getter function for cell composition matrix
#'
#' Getter function for cell composition matrix. This function allows to access
#' to the cell composition matrix of simulated training or test bulk RNA-seq
#' data.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{prob.cell.types} slot.
#' @param type.data Subset of data to show: \code{train} or \code{test}.
#'
#' @return A matrix object.
#'
#' @export
#'
#' @seealso \code{\link{generateBulkCellMatrix}}
#'
#'   
getProbMatrix <- function(object, type.data) {
  if (!is(object, "DigitalDLSorter")) {
    stop("Provided object is not a DigitalDLSorter object")
  } else if (!any(type.data == c("train", "test"))) {
    stop("'type.data' argument must be 'train' or 'test'")
  }
  return(prob.cell.types(object, type.data)@prob.matrix)
}

#' Show distribution plots of cell proportions generated by
#' \code{\link{generateBulkCellMatrix}}
#'
#' Show distribution plots of cell proportions generated by
#' \code{\link{generateBulkCellMatrix}}. These frequencies will determine the
#' proportion of different cell types used during the simulation of bulk RNA-Seq
#' samples. There are 6 subsets of proportions (1 and 2 are generated by the
#' same way) generated by different approaches that can be visualized in three
#' ways: boxplot, violinplot and linesplot. You also can represent the
#' probabilities based on the number of different cell types present in samples
#' setting \code{type.plot = 'nMix'}.
#'
#' These plots are only for diagnostic purposes. This is the reason because they
#' are generated without any parameter introduced by the user.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{prob.cell.types} slot with \code{plot} slot.
#' @param type.data Subset of data to show: \code{train} or \code{test}.
#' @param set Integer determining which of the 6 different subsets is to be
#'   shown. Note that 1 and 2 follow the same distribution.
#' @param type.plot Character determining which type of visualization is to be
#'   shown. It can be \code{boxplot}, \code{violinplot}, \code{linesplot} or
#'   \code{nmix}. See Description for more information.
#'
#' @return \code{ggplot} object.
#'
#' @export
#'
#' @seealso \code{\link{generateBulkCellMatrix}}
#'
#' @examples
#' lapply(
#'   1:6, function(x) {
#'     showProbPlot(DDLSChungComp,
#'                  type.data = "train",
#'                  set = x,
#'                  type.plot = "boxplot")
#'   }
#' )
#' 
showProbPlot <- function(
  object,
  type.data,
  set,
  type.plot = "boxplot"
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("Provided object is not a DigitalDLSorter object")
  } else if (is.null(object@prob.cell.types) || 
             (length(object@prob.cell.types) == 0)) {
    stop("'prob.cell.types' slot is empty")
  } else if (!any(type.data == c("train", "test"))) {
    stop("'type.data' argument must be 'train' or 'test'")
  } else if (length(object@prob.cell.types[[type.data]]) == 0) {
    stop("ProbMatrixCellTypes object does not present plots")
  } else if (set < 1 || set > 6) {
    stop("'set' argument must be a number from 1 to 6")
  } else if (!any(type.plot == c("violinplot", "boxplot", "linesplot", "nmix"))) {
    stop("'type.plot' argument must be one of the next options: 'violinplot', ", 
         "'boxplot', 'linesplot' or 'nmix'")
  }
  return(prob.cell.types(object, type.data)@plots[[set]][[type.plot]])
}

#' Prepare \code{\linkS4class{DigitalDLSorter}} object to be saved as RDA file
#'
#' Prepare a \code{\linkS4class{DigitalDLSorter}} object which has a
#' \code{\linkS4class{DigitalDLSorterDNN}} object with trained DNN model.
#' \code{keras} models are not able to be stored natively as R objects (e.g.
#' RData or RDS files). By saving the structure as a JSON-like character object
#' and weights as a list, it is possible to recover the model and to carry out
#' predictions. \strong{Note:} With this option, the state of optimizer is not
#' saved, only architecture and weights.
#'
#' It is possible to save completely the model as HDF5 file with
#' \code{\link{saveTrainedModelAsH5}} function and to load into
#' \code{\linkS4class{DigitalDLSorter}} object with
#' \code{\link{loadTrainedModelFromH5}} function.
#'
#' It is also possible to save a \code{\linkS4class{DigitalDLSorter}} object as
#' RDS file with \code{saveRDS} function without any type of previous
#' preparation.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{trained.data} slot.
#'
#' @export
#'
#' @seealso \code{\link{saveRDS}} \code{\link{saveTrainedModelAsH5}}
#'   
preparingToSave <- function(object) {
  if (!is(object, "DigitalDLSorter") || !is(object, "DigitalDLSorterDNN")) {
    stop("Provided object is not a DigitalDLSorter object")
  }
  if (is.null(trained.model(object))) {
    message("Provided object has not a DigitalDLSorterDNN object. It is not necessary ",
            "to prepare the object for saving to disk")
    return(object)
  } else if (is.null(trained.model(object)@model)) {
    message("Provided object has not a trained DNN model. It is not necessary ",
            "to prepare the object for saving to disk")
    return(object)
  }
  if (is(trained.model(object)@model, "list")) return(object)
  else {
    trained.model.mod <- .saveModelToJSON(trained.model(object))
    trained.model(object) <- trained.model.mod
    return(object)
  }
}

# core of barplots of deconvolution results
.barPlot <- function(
  data,
  colors,
  color.line = NA,
  x.label = "Bulk samples",
  rm.x.text = FALSE,
  title = "Results of deconvolution",
  legend.title = "Cell types",
  angle = 90
) {
  df.res <- reshape2::melt(data * 100, value.name = "Proportion")

  p <- ggplot(data = df.res, aes(x = Var1, y = Proportion, fill = Var2)) +
    geom_bar(stat = "identity", color = color.line) + theme_classic()
  if (!missing(colors)) {
    if (length(colors) < length(unique(df.res$Var2)))
      stop("Number of colors introduced is not enough to the number of cell types")
  } else {
    colors <- color.list()
  }
  p <- p + scale_fill_manual(values = colors)
  if (is.null(x.label)) {
    p <- p + theme(axis.title.x = element_blank())
  } else {
    p <- p + labs(x = x.label)
  }
  p <- p + ggtitle(title) + labs(fill = legend.title) + theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text.x = element_text(angle = angle, hjust = 1, vjust = 0.5),
    legend.title = element_text(face = "bold")
  )
  if (rm.x.text) {
    p <- p + theme(axis.ticks.x = element_blank(),
                   axis.text.x = element_blank())
  }
  return(p)
}

################################################################################
####################### Utils functions related to DNN #########################
################################################################################

#' Save on disk trained \code{\linkS4class{DigitalDLSorter}} Deep Neural Network
#' model as HDF5 file
#'
#' Save on disk the trained model in HDF5 format. Note that this function does
#' not save the \code{\linkS4class{DigitalDLSorterDNN}} object, but the trained
#' keras model.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{trained.model} slot.
#' @param file.path Valid file path where to save the model.
#' @param overwrite Overwrite file if it already exists.
#'
#' @export
#'
#' @seealso \code{\link{trainDigitalDLSorterModel}}
#'   \code{\link{loadTrainedModelFromH5}}
#'   
saveTrainedModelAsH5 <- function(
  object,
  file.path,
  overwrite = FALSE
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("Provided object is not a DigitalDLSorter object")
  } else if (is.null(trained.model(object))) {
    stop("'trained.model' slot is empty")
  } else if (is.null(trained.model(object)@model)) {
    stop("There is not a model to save on disk. First, train a model with ",
         "trainDigitalDLSorterModel function")
  }
  if (file.exists(file.path)) {
    if (overwrite) {
      message(paste(file.path, "file exists. Since 'overwrite' argument is",
                    "TRUE, it will be overwritten"))
    } else {
      stop(paste(file.path, "file exists"))
    }
  }
  if (is(trained.model(object)@model, "list")) {
    warning(paste("Trained model is not a keras object, but a R list with",
                  "architecture of network and weights. The R object will be",
                  "compiled and saved as HDF5 file, but the optimizer state",
                  "will not be saved\n\n"))
    model <- .loadModelFromJSON(trained.model(object))
    model <- model(model)
  } else {
    model <- trained.model(object)@model
  }
  tryCatch({
    save_model_hdf5(object = model,
                    filepath = file.path,
                    overwrite = overwrite,
                    include_optimizer = TRUE)
  }, error = function(cond) {
    message(paste("\nProblem during saving", file.path))
    stop(cond)
  })
}

#' Load from HDF5 file a trained DigitalDLSorter Deep Neural Network model
#'
#' Load from HDF5 file a trained  Deep Neural Network model into a
#' \code{\linkS4class{DigitalDLSorter}} object. Note that HDF5 file must be a
#' keras valid trained model.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{trained.model} slot.
#' @param file.path Valid file path where model are stored.
#' @param reset.slot Remove \code{trained.slot} if it already exists. A new
#'   \code{\link{DigitalDLSorterDNN}} object will be formed, but it will not
#'   contain other slots (\code{FALSE} by default).
#'
#' @return \code{\linkS4class{DigitalDLSorter}} object with \code{trained.model}
#'   slot with the new model loaded
#'
#' @export
#'
#' @seealso \code{\link{trainDigitalDLSorterModel}}
#'   \code{\link{deconvDigitalDLSorterObj}} \code{\link{saveTrainedModelAsH5}}
#'   
loadTrainedModelFromH5 <- function(
  object,
  file.path,
  reset.slot = FALSE
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("Provided object is not a DigitalDLSorter object")
  } else if (!file.exists(file.path)) {
    stop(paste(file.path, "file does not exist. Please, provide a valid file path"))
  }
  if (!is.null(trained.model(object))) {
    slot.exists <- TRUE
    message("'trained.model' slot is not empty:")
    if (reset.slot) {
      message("  'reset.slot' is TRUE, 'trained.model' slot will be restart")
    } else {
      message("  'reset.slot' is FALSE, only 'model' slot of DigitalDLSorterDNN",
              "object will be overwritten")
    }
  } else {
    slot.exists <- FALSE
  }
  tryCatch({
    loaded.model <- load_model_hdf5(filepath = file.path, compile = TRUE)
  }, error = function(cond) {
    message(paste("\n", file.path, "file provided is not a valid Keras model:"))
    stop(cond)
  })
  if (!slot.exists) {
    model <- new(Class = "DigitalDLSorterDNN",
                 model = loaded.model)
  } else {
    if (reset.slot) {
      model <- new(Class = "DigitalDLSorterDNN",
                   model = loaded.model)
    } else {
      model(object@trained.model) <- loaded.model
      return(object)
    }
  }
  trained.model(object) <- model
  return(object)
}

#' Plot training history of a trained DigitalDLSorter Deep Neural Network model
#'
#' Plot training history of a trained DigitalDLSorter Deep Neural Network model.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{trained.model} slot.
#' @param title Title of plot.
#' @param metrics Which metrics to plot. If it is equal to \code{NULL} (by
#'   default), all metrics available on \code{\linkS4class{DigitalDLSorterDNN}}
#'   object will be plotted.
#'
#' @export
#'
#' @seealso \code{\link{trainDigitalDLSorterModel}}
#'   \code{\link{deconvDigitalDLSorterObj}}
#'   
plotTrainingHistory <- function(
  object,
  title = "History of metrics during training",
  metrics = NULL
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("Provided object is not of DigitalDLSorter class")
  } else if (is.null(trained.model(object))) {
    stop("'trained.model' slot is empty")
  } else if (is.null(trained.model(object)@training.history)) {
    stop("There is not training history in the provided object")
  }
  if (!is.null(metrics)) {
    if (!all(metrics %in% names(trained.model(object)@training.history$metrics))) {
      stop("Some of the given metrics are not present in the provided object")
    }
  }
  plot(trained.model(object)@training.history,
       metrics = metrics, method = "ggplot2") + ggtitle(title)
}


#' Load data to deconvolute from a tabulated text file
#'
#' Load data to deconvolute from a tabulated text file. Accepted formats are tsv
#' and tsv.gz. You must specify the correct extension.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{trained.model} slot.
#' @param file.path File path where data is stored.
#' @param name.data Name with which the data is stored in
#'   \code{\linkS4class{DigitalDLSorter}} object. If \code{name.data} is not
#'   provided, base name of file is used.
#'
#' @return \code{\linkS4class{DigitalDLSorter}} object with \code{deconv.data}
#'   slot with the new bulk-RNAseq samples loaded
#'
#' @export
#'
#' @seealso \code{\link{trainDigitalDLSorterModel}}
#'   \code{\link{deconvDigitalDLSorterObj}}
#'   
loadDeconvDataFromFile <- function(
  object,
  file.path,
  name.data = NULL
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("Provided object is not of DigitalDLSorter class")
  }
  counts <- .readTabFiles(file = file.path)
  se.object <- SummarizedExperiment::SummarizedExperiment(
    assays = list(counts = counts),
    rowData = data.frame(rownames(counts)),
    colData = data.frame(colnames(counts)),
  )
  # generate name for data if is not provided
  if (is.null(name.data)) {
    name.data <- tools::file_path_sans_ext(basename(file.path))
  }
  # create or not a new list
  if (is.null(object@deconv.data)) list.data <- list()
  else list.data <- object@deconv.data
  # check if name.data exists
  if (name.data %in% names(list.data)) {
    stop(paste(name.data, "data already exists in 'deconv.data' slot"))
  }
  list.data[[name.data]] <- se.object
  object@deconv.data <- list.data
  
  return(object)
}


## check si la matriz tiene colnames y rownames
## hacer genérica y que funcione de forma diferente en función de si es
## SummarizedExperiment o matrix


#' Load data to deconvolute from a \code{\linkS4class{SummarizedExperiment}}
#' object
#'
#' Load data in \code{\linkS4class{DigitalDLSorter}} object to deconvolute from
#' \code{\linkS4class{SummarizedExperiment}} object.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{trained.model} slot.
#' @param se.object \code{\linkS4class{SummarizedExperiment}} object.
#' @param name.data Name with which the data is stored in
#'   \code{\linkS4class{DigitalDLSorter}} object.
#'
#' @return \code{\linkS4class{DigitalDLSorter}} object with \code{deconv.data}
#'   slot with the new bulk-RNAseq samples loaded
#'
#' @export
#'
#' @seealso \code{\link{trainDigitalDLSorterModel}}
#'   \code{\link{deconvDigitalDLSorterObj}}
#'   
loadDeconvDataFromSummarizedExperiment <- function(
  object,
  se.object,
  name.data = NULL
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("The provided object is not of DigitalDLSorter class")
  } else if (!is(se.object, "SummarizedExperiment")) {
    stop("The provided object is not of SummarizedExperiment class")
  }
  if (length(assays(se.object)) == 0) {
    stop("assay slot of SummarizedExperiment object is empty")
  } else if (length(assays(se.object)) > 1) {
    warning(paste("There are more than one assays in SummarizedExperiment object,",
                  "only the first assay will be considered. Remember that it is", "
                  recommended that the provided data be of the same nature as",
                  "the data with which the model has been trained (e.g. TPMs)"))
  }
  # generate name for data if is not provided
  if (is.null(name.data)) {
    if (is.null(deconv.data(object))) {
      name.data <- "deconv_1"
    } else {
      name.data <- paste0("decon_", length(deconv.data(object)) + 1)
    }
  }
  # create or not a new list
  if (is.null(deconv.data(object))) list.data <- list()
  else list.data <- deconv.data(object)
  # check if name.data exists
  if (name.data %in% names(list.data)) {
    stop(paste(name.data, "data already exists in deconv.data slot"))
  }
  list.data[[name.data]] <- se.object
  deconv.data(object) <- list.data
  
  return(object)
}
