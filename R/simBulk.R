#' @importFrom ggplot2 ggplot aes geom_violin geom_boxplot geom_line theme ggtitle element_text
NULL


################################################################################
####################### Generate cell composition matrix #######################
################################################################################

#' Generate training and test cell composition matrices
#'
#' Generate training and test cell composition matrices for the simulation of
#' bulk RNA-seq samples with known cell composition using single-cell expression
#' profiles. The resulting \code{\linkS4class{ProbMatrixCellTypes}} object
#' contains a matrix which determines the proportion of the different cell types
#' that will compose the simulated bulk samples. Moreover, this object also
#' contains other information relevant to the process. This function does not
#' simulate bulk samples, this task is performed by
#' \code{\link{simBulkProfiles}} or \code{\link{trainDigitalDLSorterModel}}
#' functions (see Documentation).
#'
#' First, available single-cell profiles are split into training and test
#' subsets (2/3 for training and 1/3 for test by default (see
#' \code{train.freq.cells})) in order to avoid falsifying the results during the
#' evaluation of the model. Then, \code{num.bulk.samples} bulk samples
#' proportions are built and single-cell profiles that will be used for
#' simulating each bulk RNA-seq sample are set, being 100 cells per bulk sample
#' by default (see \code{n.cells} argument). The proportions of training and
#' test bulk samples are set by \code{train.freq.bulk} (2/3 for training and 1/3
#' for test by default). Finally, in order to avoid biases due to the
#' composition of the bulk RNA-seq, proportions of cell types
#' (\eqn{w_1,...,w_k}, where \eqn{k} is the number of cell types available in
#' single-cell profiles) are randomly generated by using five different
#' approaches:
#'
#' \enumerate{ \item Cell proportions are randomly sampled from a truncated
#' uniform distribution with predefined limits according to a priori knowledge
#' of the abundance of each cell type (see \code{prob.design} argument). This
#' information can be inferred from the single-cell experiment itself or from
#' the literature. \item A second set is generated by randomly permuting cell
#' type labels from a distribution generated by the previous method. \item Cell
#' proportions are randomly sampled as by method 1 without replacement. \item
#' Using the last method for generating proportions, cell types labels are
#' randomly sampled. \item Cell proportions are randomly sampled from a
#' Dirichlet distribution.}
#'
#' If you want to inspect the distribution of cell type proportions generated by
#' each method during the process, they can be shown by
#' \code{\link{showProbPlot}} function (see Documentation).
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{single.cell.real} slot and, optionally, with \code{single.cell.simul}
#'   slot.
#' @param cell.ID.column Name or column number corresponding to cell names of
#'   expression matrix in cells metadata.
#' @param cell.type.column Name or column number corresponding to cell type of
#'   each cell in cells metadata.
#' @param prob.design data.frame with the frequency ranges expected for each
#'   cell type present in the experiment. This information can be estimated from
#'   literature or from the single-cell experiment itself. This data.frame must
#'   be built by three columns with specific headers (see examples): \itemize{
#'   \item A cell type column with the same name of the cell type column in
#'   cells metadata (\code{cell.type.column}). If the name of the column is not
#'   the same, function returns an error. All cell types must appear in cells
#'   metadata. \item A second column named \code{'from'} with the start
#'   frequency for each cell type. \item A third column named \code{'to'} with
#'   the final frequency for each cell type.}
#' @param num.bulk.samples Number of bulk RNA-seq samples proportions (and
#'   therefore, simulated bulk RNA-seq samples) that will be generated taking
#'   into account training and test data. We recommend seting this value
#'   according to the number of single-cell profiles available in
#'   \code{\linkS4class{DigitalDLSorter}} object avoiding an excesive
#'   re-sampling, but generating a big number of samples for a better training.
#' @param n.cells Number of cells that will be aggregated in order to simulate
#'   one bulk RNA-seq sample (100 by default).
#' @param train.freq.cells Proportion of cells used for simulating training bulk
#'   samples (2/3 by default).
#' @param train.freq.bulk Proportion of bulk RNA-seq samples from the total
#'   number (\code{num.bulk.samples}) used for training set (2/3 by default).
#' @param proportions.train Vector of five integers that determines the
#'   proportions of bulk samples generated by the different methods (see Details
#'   and Torroja and Sánchez-Cabo, 2019 for more information). This vector
#'   represents proportions, so its entries must add up 100. By default, a
#'   majority of random samples without using predefined ranges will be
#'   generated.
#' @param proportions.test \code{proportions.train} for test samples.
#' @param balanced.type.cells Boolean indicating if training and test cells will
#'   be split in a balanced way considering cell types (\code{FALSE} by
#'   default).
#' @param verbose Show informative messages during the execution (\code{TRUE} by
#'   default).
#'
#' @return A \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{prob.cell.types} slot containing a \code{list} with two
#'   \code{\linkS4class{ProbMatrixCellTypes}} objects (training and test). For
#'   more information about the structure of this class, see
#'   \code{?\linkS4class{ProbMatrixCellTypes}}.
#'
#' @export
#'
#' @seealso \code{\link{simBulkProfiles}}
#'   \code{\linkS4class{ProbMatrixCellTypes}}
#'
#' @examples
#' ## generate a data.frame with frequency ranges of each cell type
#' probMatrix <- data.frame(
#'   Cell_type = c("ER+", "HER2+", "ER+ and HER2+", "TNBC",
#'                 "Stromal", "Monocyte", "Tme", "BGC",
#'                 "Bmem", "DC", "Macrophage", "TCD8", "Treg"),
#'   from = c(rep(30, 4), 1, rep(0, 8)),
#'   to = c(rep(70, 4), 50, rep(15, 8))
#' )
#' \dontrun{
#'   DDLSChung <- generateBulkCellMatrix(
#'     object = DDLSChung,
#'     cell.type.column = "Cell_type",
#'     cell.ID.column = "Cell_ID",
#'     prob.design = probMatrix,
#'     num.bulk.samples = 100,
#'     verbose = TRUE
#'   )
#' }
#'
#' @references Torroja, C. y Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep
#'   Learning algorithm to quantify immune cell populations based on scRNA-Seq
#'   data. Frontiers in Genetics 10, 978. doi:
#'   \href{https://doi.org/10.3389/fgene.2019.00978}{10.3389/fgene.2019.00978}
#'   
generateBulkCellMatrix <- function(
  object,
  cell.ID.column,
  cell.type.column,
  prob.design,
  num.bulk.samples,
  n.cells = 100,
  train.freq.cells = 2/3,
  train.freq.bulk = 2/3,
  proportions.train = c(10, 5, 20, 15, 10, 40),
  proportions.test = c(10, 5, 20, 15, 10, 40),
  balanced.type.cells = FALSE,
  verbose = TRUE
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("The object provided is not of DigitalDLSorter class")
  } else if (is.null(single.cell.real(object))) {
    stop("'single.cell.real' slot is empty")
  } else if (!train.freq.cells <= 0.95 || !train.freq.cells >= 0.05) {
    stop("'train.seq.cells' argument must be less than or equal to 0.95 and ", 
         "greater than or equal to 0.05")
  } else if (!train.freq.bulk <= 0.95 || !train.freq.bulk >= 0.05) {
    stop("'train.seq.bulk' argument must be less than or equal to 0.95 and ", 
         "greater than or equal to 0.05")
  } else if (missing(cell.ID.column) || missing(cell.type.column) || 
             is.null(cell.ID.column) || is.null(cell.type.column)) {
    stop("'cell.ID.column' and 'cell.type.column' arguments are needed. Please, ", 
         "look at ?estimateZinbwaveParams") 
  } else if (!is.data.frame(prob.design)) {
    stop(paste(
      "prob.design must be a data frame with three column names:",
      paste("'cell.type.column': must be equal to 'cell.type.column' in",
            "cells metadata (colData slot of SingleCellExperiment objects)"),
      "'from': frequency from which the cell type can appear",
      "'to': frequency up to which the cell type can appear", 
      sep = "\n   - ")
    )
  } else if (sum(proportions.train) != 100 ||
             sum(proportions.test) != 100) {
    stop("Proportions provided must add up to 100")
  } else if (length(proportions.train) != 6 || length(proportions.test) != 6) {
    stop("Proportions must be a vector of six elements")
  } else if (missing(num.bulk.samples) || is.null(num.bulk.samples)) {
    stop("'num.bulk.samples' argument must be provided")
  } else if (any(proportions.train < 0) || any(proportions.test < 0)) {
    stop("Proportions cannot be lesser than zero")
  }
  if (!is.null(prob.cell.types(object)) || !length(prob.cell.types(object)) == 0) {
    warning("'prob.cell.types' slot already has probability matrices. ", 
            "Note that this object will be overwritten\n\n",
            call. = FALSE, immediate. = TRUE)
  }
  if (!all(unlist(lapply(X = list(proportions.train, proportions.test),
                         FUN = function(x) all(x == floor(x)))))) {
    stop("Proportions provided must be composed of integers")
  }
  
  if (!is.null(single.cell.simul(object))) {
    # extract data from SCE to list
    list.metadata <- list(
      single.cell.real(object) %>% 
        SingleCellExperiment::colData(),
      single.cell.simul(object) %>% 
        SingleCellExperiment::colData()
    )
    # check if cell.type.column and cell.ID.column are correct
    lapply(
      X = list(list.metadata[[1]], list.metadata[[2]]),
      FUN = function(x) {
        mapply(
          function(y, z) {
            .checkColumn(
              metadata = x,
              ID.column = y,
              type.metadata = "cells.metadata",
              arg = z
            )
          },
          c(cell.ID.column, cell.type.column),
          c("cell.ID.column", "cell.type.column")
        )
      }
    )
    # list.metadata[[1]][, cell.ID.column] <- paste(
    #   list.metadata[[1]][, cell.type.column], 
    #   list.metadata[[1]][, cell.ID.column], sep = "_"
    # )
    # list.metadata[[1]]$simCellName <- list.metadata[[1]][, cell.ID.column]
    list.metadata[[1]]$Simulated <- FALSE
    list.metadata[[1]]$sufix <- ""
    cells.metadata <- S4Vectors::rbind(list.metadata[[1]], list.metadata[[2]])  
  } else {
    cells.metadata <- single.cell.real(object) %>% 
      SingleCellExperiment::colData()
  }
  # check if prob.design is correctly built
  lapply(
    X = c(cell.type.column, "from", "to"),
    FUN = function(x) {
      .checkColumn(
        metadata = prob.design,
        ID.column = x,
        type.metadata = "prob.design",
        arg = ""
      )
    }
  )
  if (any(duplicated(prob.design[, cell.type.column]))) {
    stop(paste("'prob.design' must not contain duplicated cell types in",
               cell.type.column, "column"))
  } else if (!all(prob.design[, cell.type.column] %in%
                  unique(cells.metadata[, cell.type.column]))) {
    stop("There are some cell types in 'prob.design' that do not appear in ", 
         "cells metadata. Check that the 'prob.design' matrix is correctly built")
  } else if (any(prob.design$from < 0) || any(prob.design$from > 99)) {
    stop("'from' column in 'prob.design' must be greater than or equal to 0 and ",
         "lesser than or equal to 99")
  } else if (any(prob.design$to < 1) || any(prob.design$to > 100)) {
    stop("'to' column in 'prob.design' must be greater than or equal to 1 and ", 
         "lesser than or equal to 100")
  } else if (any(prob.design$from > prob.design$to)) {
    stop("'from' entries must be lesser than 'to' entries")
  } else if (any(abs(prob.design$from) + abs(prob.design$to) > 100)) {
    stop("The sum between the 'from' and 'to' entries must not be greater than", 
         " 100")
  }
  ## check if n.cells is invalid
  if (n.cells <= 0) {
    stop("'n.cells' must be greater than zero")
  } else if (n.cells < length(unique(cells.metadata[, cell.type.column]))) {
    stop("'n.cells' must be equal to or greater than the number of cell types in",
         " experiment. We recommend more than 100 cells per bulk sample")
  }
  # check proportions --> avoid num.bulk.samples too low
  total.train <- ceiling(num.bulk.samples * train.freq.bulk)
  total.test <- num.bulk.samples - total.train
  if (total.test == 0) 
    stop("'num.bulk.samples' too low in relation to 'train.freq.bulk'")
  nums.train <- .setHundredLimit(
    ceiling((total.train * proportions.train) / 100),
    limit = total.train
  )
  nums.test <- .setHundredLimit(
    ceiling((total.test * proportions.test) / 100),
    limit = total.test
  )
  if (verbose) {
    message(paste("\n=== The number of bulk RNA-seq samples that will be generated", 
                  "has been fixed to", num.bulk.samples))  
  }
  # split data into training and test sets
  cells <- cells.metadata[, cell.ID.column]
  names(cells) <- cells.metadata[, cell.type.column]
  # train set: 
  # balanced.type.cells == TRUE --> same number of cells by cell types
  # balanced.type.cells == FALSE --> completely random
  if (!balanced.type.cells) {
    train.set <- sample(cells, size = round(nrow(cells.metadata) * train.freq.cells))
    if (length(unique(names(train.set))) != length(unique(names(cells)))) {
      train.set <- sapply(
        X = unique(names(cells)), 
        FUN = function(x, cells, train.freq.cells) {
          sample(
            cells[names(cells) == x], 
            size = round(length(cells[names(cells) == x]) * train.freq.cells)
          )
        }, cells = cells, train.freq.cells
      ) %>% unname() %>% unlist()  
    }
  } else {
    train.set <- sapply(
      X = unique(names(cells)), 
      FUN = function(x, cells, train.freq.cells) {
        sample(
          cells[names(cells) == x], 
          size = round(length(cells[names(cells) == x]) * train.freq.cells)
        )
      }, cells = cells, train.freq.cells
    ) %>% unname() %>% unlist()
  }
  train.types <- names(train.set)
  train.set.list <- list()
  # sort cell types in order to speed up reading times in HDF5 files --> 
  # same order as are stored simulated cells in HDF5 file (unnecessary)
  if (!is.null(zinb.params(object))) {
    model.cell.types <- grep(pattern = cell.type.column,
                             x = colnames(zinb.params(object)@model@X),
                             value = T)
    cell.type.names <- sub(pattern = cell.type.column,
                           replacement = "",
                           x = model.cell.types)
    if (any(levels(factor(train.types)) %in% cell.type.names)) {
      cell.type.names <- c(
        cell.type.names,
        setdiff(levels(factor(train.types)), cell.type.names)
      )
    }
  } else {
    cell.type.names <- levels(factor(train.types))
  }
  cell.type.train <- cell.type.names[cell.type.names %in% levels(factor(train.types))]
  for (ts in cell.type.train) {
    train.set.list[[ts]] <- train.set[train.types == ts]
  }
  # test set
  test.set <- cells[!cells %in% train.set]
  test.types <- names(test.set)
  test.set.list <- list()
  cell.type.test <- cell.type.names[cell.type.names %in% levels(factor(test.types))]
  # print(cell.type.test)
  for (ts in cell.type.test) {
    test.set.list[[ts]] <- test.set[test.types == ts]
  }
  
  # check if all cell types are present in train and test data
  if (verbose) {
    message("\n=== Training set cells by type:")
    tb <- unlist(lapply(train.set.list, length))
    message(paste0("    - ", names(tb), ": ", tb, collapse = "\n"), "\n")
    message("=== Test set cells by type:")
    tb <- unlist(lapply(test.set.list, length))
    message(paste0("    - ", names(tb), ": ", tb, collapse = "\n"), "\n")
  }
  # take prob.design
  prob.list <- apply(
    X = prob.design, MARGIN = 1,
    FUN = function (x) {
      return(seq(from = x['from'], to = x['to']))
    }
  )
  names(prob.list) <- prob.design[, cell.type.column]
  
  n.cell.types <- length(unique(train.types))
  functions.list <- list(.generateSet1, .generateSet2, .generateSet3,
                         .generateSet4, .generateSet5, .generateSet6)
  ## resume this code by using a loop or do.call implementation, because the code 
  ## is duplicated (is the same for training and test)
  # TRAIN SETS -----------------------------------------------------------------
  excl.cell.type <- c(NULL, NULL, NULL, NULL, NULL, NULL)
  train.prob.matrix <- matrix(rep(0, n.cell.types), nrow = 1, byrow = TRUE)
  colnames(train.prob.matrix) <- names(prob.list)
  train.plots <- list()
  n <- 1
  first <- TRUE
  for (fun in functions.list) {
    if (nums.train[n] == 0) {
      n <- n + 1
      next
    }
    train.probs <- fun(
      prob.list = prob.list,
      prob.matrix = train.prob.matrix,
      num = nums.train[n],
      s.cells = total.train,
      n.cell.types = n.cell.types,
      index.ex = excl.cell.type[n]
    )
    train.prob.matrix <- rbind(train.prob.matrix, train.probs)
    if (first) {
      train.prob.matrix <- train.prob.matrix[-1, , drop = FALSE]
      first <- FALSE
    }
    train.plots[[n]] <- .plotsQCSets(
      probs = train.probs,
      prob.matrix = train.prob.matrix,
      n = n,
      set = "train"
    )
    n <- n + 1
  }
  # check if matrix is correctly built
  if (is.null(dim(train.prob.matrix))) 
    train.prob.matrix <- matrix(train.prob.matrix, nrow = 1)
  if (is.null(colnames(train.prob.matrix)))
    colnames(train.prob.matrix) <- prob.design[, cell.type.column]
  
  rownames(train.prob.matrix) <- paste("Bulk", seq(dim(train.prob.matrix)[1]),
                                       sep = "_")
  train.plots <- train.plots[!unlist(lapply(train.plots, is.null))]
  
  if (verbose) {
    message("=== Probability matrix for training data:")
    message(paste(c("    - Bulk RNA-seq samples:", "    - Cell types:"),
                  dim(train.prob.matrix),
                  collapse = "\n"), "\n")
  }
  # TEST SETS ------------------------------------------------------------------
  test.prob.matrix <- matrix(rep(0, n.cell.types), nrow = 1, byrow = T)
  test.plots <- list()
  n <- 1
  first <- TRUE
  for (fun in functions.list) {
    if (nums.test[n] == 0) {
      n <- n + 1
      next
    }
    test.probs <- fun(
      prob.list = prob.list,
      prob.matrix = test.prob.matrix,
      num = nums.test[n],
      s.cells = total.test,
      n.cell.types = n.cell.types,
      index.ex = excl.cell.type[n]
    )
    test.prob.matrix <- rbind(test.prob.matrix, test.probs)
    if (first && nums.test[n] != 0) {
      test.prob.matrix <- test.prob.matrix[-1, ]
      first <- FALSE
    }
    test.plots[[n]] <- .plotsQCSets(
      probs = test.probs,
      prob.matrix = test.prob.matrix,
      n = n,
      set = "test"
    )
    n <- n + 1
  }
  # check if matrix is correctly built
  if (is.null(dim(test.prob.matrix))) 
    test.prob.matrix <- matrix(test.prob.matrix, nrow = 1)
  if (is.null(colnames(test.prob.matrix)))
    colnames(test.prob.matrix) <- prob.design[, cell.type.column]
  
  rownames(test.prob.matrix) <- paste("Bulk", seq(dim(test.prob.matrix)[1]),
                                      sep = "_")
  test.plots <- test.plots[!unlist(lapply(test.plots, is.null))]
  
  if (verbose) {
    message("=== Probability matrix for test data:")
    message(paste(c("    - Bulk RNA-seq samples:", "    - Cell types:"),
                  dim(test.prob.matrix),
                  collapse = "\n"), "\n")
  }
  # GENERATE PROBS MATRIX NAMES ------------------------------------------------
  train.prob.matrix.names <- t(apply(
    X = train.prob.matrix,
    MARGIN = 1,
    FUN = setCount,
    setList = train.set.list,
    sn = colnames(train.prob.matrix),
    n.cells = n.cells
  ))

  test.prob.matrix.names <- t(apply(
    X = test.prob.matrix,
    MARGIN = 1,
    FUN = setCount,
    setList = test.set.list,
    sn = colnames(test.prob.matrix),
    n.cells = n.cells
  ))

  # generate object of ProbMatrixCellTypes class
  train.prob.matrix.object <- new(
    Class = "ProbMatrixCellTypes",
    prob.matrix = train.prob.matrix,
    cell.names = train.prob.matrix.names,
    set.list = train.set.list,
    set = train.set,
    plots = train.plots,
    type.data = "train"
  )
  test.prob.matrix.object <- new(
    Class = "ProbMatrixCellTypes",
    prob.matrix = test.prob.matrix,
    cell.names = test.prob.matrix.names,
    set.list = test.set.list,
    set = test.set,
    plots = test.plots,
    type.data = "test"
  )
  prob.cell.types(object) <- list(
    train = train.prob.matrix.object,
    test = test.prob.matrix.object
  )
  if (verbose) message("DONE")
  return(object)
}

.violinPlot <- function(
  df, 
  title, 
  x = "CellType", 
  y = "Prob"
) {
  plot <- ggplot(df, aes(x = .data[[x]], y = .data[[y]])) +
    geom_violin() + ggtitle(title) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  return(plot)
}

.boxPlot <- function(
  df, 
  title, 
  x = "CellType", 
  y = "Prob"
) {
  plot <- ggplot(df, aes(x = .data[[x]], y = .data[[y]])) +
    geom_boxplot() + ggtitle(title) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  return(plot)
}

.linesPlot <- function(
  df, 
  title, 
  x = "CellType", 
  y = "Prob", 
  group = "Sample"
) {
  plot <- ggplot(df, aes(x = .data[[x]], y = .data[[y]],
                        group = .data[[group]])) +
    geom_line(colour = "grey60") + ggtitle(title) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
  return(plot)
}

.plotsQCSets <- function(
  probs, 
  prob.matrix, 
  n, 
  set
) {
  title <- paste0("Bulk Probability Dist. Set ", n, " (", set, ")")
  n.samples <- paste("# samples:", dim(probs)[1])
  plots.functions <- list(.violinPlot, .boxPlot, .linesPlot)
  df <- reshape2::melt(probs)
  colnames(df) <- c("Sample", "CellType", "Prob")
  # first three plots
  plot.list <- lapply(plots.functions, function(f) f(df, paste(title, n.samples)))
  # final plots
  dummy <- t(apply(as.matrix(prob.matrix), 1, sort, decreasing = T))
  df <- reshape2::melt(dummy)
  colnames(df) <- c("Sample", "nMix", "Prob")
  df$nMix <- factor(df$nMix)
  plot.list[[4]] <- .boxPlot(df = df, x = "nMix", title = title)
  names(plot.list) <- c("violinplot", "boxplot", "linesplot", "nmix")
  return(plot.list)
}

setCount <- function(
  x, 
  setList, 
  sn, 
  n.cells
) {
  names(x) <- sn
  sc <- c()
  x.set <- .setHundredLimit(x = (x * n.cells) / 100, limit = n.cells)
  for (cType in names(x)) {
    n <- ceiling(x.set[cType]) # n <- ceiling(x[cType])
    if (n > 0) {
      repl <- ifelse(n > length(setList[[cType]]), TRUE, FALSE)
      sc <- c(sc, sample(setList[[cType]], size = n, replace = repl))
    }
  }
  return(sc[seq(n.cells)])
}

# introduce zeros in selected proportions. when these samples will be 
# simulated, they will have zero values in these cell types
.cellExcluder <- function(vec, index.ex) {
  # sel <- sample(x = index.ex, size = length(index.ex)) # -1
  vec[index.ex] <- 0
  return(list(vec, index.ex))
}

# recursive implementation, maybe improvable
.setHundredLimit <- function(
  x, 
  index.ex = NULL, 
  limit = 100
) {
  if (sum(x) > limit) {
    while (TRUE) {
      if (is.null(index.ex)) {
        sel <- sample(seq(length(x)), 1)
      } else {
        sel <- sample(seq(length(x))[-index.ex], 1)
      }
      res <- x[sel] - abs(sum(x) - limit)
      if (res < 0) res <- x[sel] - sample(x[sel], 1)
      if (res >= 0) break
    }
    x[sel] <- res
  } else if (sum(x) < limit) {
    while (TRUE) {
      if (is.null(index.ex)) {
        sel <- sample(seq(length(x)), 1)
      } else {
        sel <- sample(seq(length(x))[-index.ex], 1)
      }
      res <- x[sel] + abs(sum(x) - limit)
      if (res <= limit) break
    }
    x[sel] <- res
  }
  if (sum(x) != limit) 
    return(.setHundredLimit(x = x, index.ex = index.ex, limit = limit))
  else 
    return(x)
}

# wrapper function of .setHundredLimit. This function is able to enter zero
# values while respecting all other proportions
.adjustHundred <- function(
  x,
  prob.list,
  index.ex = NULL,
  sampling = TRUE
) {
  w <- unlist(lapply(prob.list, sample, 1))
  # remove cell types if needed
  if (!is.null(index.ex)) {
    x.list <- .cellExcluder(vec = x, index.ex = index.ex)
    x <- x.list[[1]]
    w[x.list[[2]]] <- 0
  }
  d <- abs(sum(x) - 100)
  if (sum(x) > 100) {
    div.w <- (w / sum(w)) * d
    while (!all(x >= div.w)) {
      index <- which(!x >= div.w)
      w[index] <- 0
      div.w <- (w / sum(w)) * d
    }
    x <- round(x - div.w)
    x <- .setHundredLimit(x = x, index.ex = index.ex)
  } else if (sum(x) < 100) {
    div.w <- (w / sum(w)) * d
    while (!all(100 - div.w > x)) {
      index <- which(!100 - div.w > x)
      w[index] <- 0
      div.w <- (w / sum(w)) * d
    }
    x <- round(x + div.w)
    x <- .setHundredLimit(x = x, index.ex = index.ex)
  }
  return(x)
}

.generateSet1 <- function(
  prob.list,
  prob.matrix,
  num,
  s.cells,
  n.cell.types,
  index.ex
) {
  if (!is.null(index.ex)) {
    sampling <- function(prob.list) {
      x <- .cellExcluder(
        vec = unlist(lapply(X = prob.list, FUN = sample, 1)),
        index.ex = index.ex
      )
      return(x[[1]])
    }
  } else {
    sampling <- function(prob.list) unlist(lapply(X = prob.list, FUN = sample, 1))
  }
  # n <- ceiling(num * s.cells / 1000)
  n <- num
  while (dim(prob.matrix)[1] <= n) {
    prob.matrix <- rbind(prob.matrix, sampling(prob.list = prob.list))
  }
  prob.matrix <- prob.matrix[-1, , drop = FALSE]
  prob.matrix <- round(prob.matrix * 100 / rowSums(prob.matrix))
  prob.matrix <- t(apply(
    X = prob.matrix, MARGIN = 1, FUN = .setHundredLimit, index.ex
  ))
  return(prob.matrix)
}

.generateSet2 <- function(
  prob.list,
  prob.matrix,
  num,
  s.cells,
  n.cell.types,
  index.ex
) {
  probs <- list()
  # n <- ceiling(num * s.cells/1000)
  n <- num
  if (!is.null(index.ex)) {
    sampling <- function(prob.list) {
      x <- .cellExcluder(
        vec = unlist(lapply(X = prob.list, FUN = sample, 1)),
        index.ex = index.ex
      )
      return(x[[1]])
    }
  } else {
    sampling <- function(prob.list) unlist(lapply(X = prob.list, FUN = sample, 1))
  }
  while (length(probs) < n) {
    probs[[length(probs) + 1]] <- sampling(prob.list = prob.list)
  }
  probs <- lapply(X = probs, FUN = function(x) return(round(x * 100 / sum(x))))
  probs <- lapply(X = probs, FUN = sample)
  probs <- lapply(X = probs, FUN = function(x) x[names(prob.list)])
  probs <- matrix(unlist(probs), nrow = n, byrow = TRUE)
  probs <- t(
    apply(
      X = probs, 1, 
      FUN = function(x) {
        .adjustHundred(
          x = x,
          prob.list = prob.list,
          index.ex = index.ex
        )
      }
    )
  )
  colnames(probs) <- colnames(prob.matrix)
  return(probs)
}

.generateSet3 <- function(
  prob.list,
  prob.matrix,
  num,
  s.cells,
  n.cell.types,
  index.ex
) {
  if (!is.null(index.ex)) {
    sampling <- function(p) {
      p <- .cellExcluder(vec = sample(p), index.ex = index.ex)
      return(p[[1]])
    }
  } else {
    sampling <- function(p) sample(p)
  }
  probs <- list()
  n <- num
  while (length(probs) < n) {
    p <- rep(0, n.cell.types)
    i <- 1
    while (sum(p) < 100) {
      p[i] <- p[i] + sample(seq(100 - sum(p)), size = 1)
      i <- i + 1
      if (i > n.cell.types) i <- 1
    }
    p <- sampling(p)
    if (sum(p == 0) < n.cell.types) probs[[length(probs) + 1]] <- p
  }
  probs <- matrix(unlist(probs), nrow = n, byrow = T)
  colnames(probs) <- colnames(prob.matrix)
  probs <- round(probs * 100 / rowSums(probs))
  if (any(rowSums(probs) != 100))
    probs <- t(apply(X = probs, MARGIN = 1, FUN = .setHundredLimit, index.ex))
  return(probs)
}

.generateSet4 <- function(
  prob.list,
  prob.matrix,
  num,
  s.cells,
  n.cell.types,
  index.ex
) {
  probs <- list()
  # n <- ceiling(num * s.cells/1000)
  n <- num
  while(length(probs) < n) {
    p <- rep(0, n.cell.types)
    names(p) <- names(prob.list)
    i <- 1
    while (sum(p) < 100) {
      dp <- 101
      while (dp > max(prob.list[[i]])) {
        dp <- sample(prob.list[[i]], size = 1)
      }
      p[i] <- dp
      i <- i + 1
      if (i > n.cell.types) i <- 1
    }
    p[1] <- p[1] + 1
    p <- sample(p)
    if (sum(p == 0) < n.cell.types) probs[[length(probs) + 1]] <- p
  }
  # probs <- lapply(X = probs, FUN = function(x) return(x[names(prob.list)]))
  probs <- matrix(unlist(probs), nrow = n, byrow = T)
  colnames(probs) <- colnames(prob.matrix)
  probs <- round(probs * 100 / rowSums(probs))
  if (any(rowSums(probs) != 100)) {
    probs <- t(
      apply(
        X = probs, 
        MARGIN = 1,
        FUN = function(x) {
          .adjustHundred(
            x = x,
            prob.list = prob.list,
            index.ex = index.ex
          )
        }
      )
    )  
  }
  return(probs)
}

.generateSet5 <- function(
  prob.list,
  prob.matrix,
  num,
  s.cells,
  n.cell.types,
  index.ex
) {
  probs <- list()
  # n <- ceiling(num * s.cells/1000)
  n <- num
  while(length(probs) < n) {
    p <- rep(0, n.cell.types)
    names(p) <- names(prob.list)
    i <- 1
    while (sum(p) < 100) {
      dp <- sample(prob.list[[i]], size = 1)
      p[i] <- dp
      i <- i + 1
      if (i > n.cell.types) i <- 1
    }
    p[1] <- p[1] + 1
    p <- sample(p)
    if (sum(p == 0) < n.cell.types) probs[[length(probs) + 1]] <- p
  }
  probs <- lapply(X = probs, FUN = sample)
  probs <- matrix(unlist(probs), nrow = n, byrow = T)
  colnames(probs) <- colnames(prob.matrix)
  probs <- round(probs * 100 / rowSums(probs))
  if (any(rowSums(probs) != 100)) {
    probs <- t(
      apply(
        X = probs, 
        MARGIN = 1,
        FUN = function(x) {
          .adjustHundred(
            x = x,
            prob.list = prob.list,
            index.ex = index.ex
          )
        }
      )
    )
  }
  return(probs)
}

.generateSet6 <- function(
  prob.list,
  prob.matrix,
  num,
  s.cells,
  n.cell.types,
  index.ex
) {
  # n <- ceiling(num * s.cells/1000)
  n <- num
  if (!is.null(index.ex)) {
    generator <- function() {
      gtools::rdirichlet(
        n = 1,
        alpha = .cellExcluder(rep(1, n.cell.types), index.ex = index.ex)[[1]]
      )
    }
    probs <- t(replicate(n = n, expr = generator(), simplify = TRUE))
  } else {
    probs <- gtools::rdirichlet(n, rep(1, n.cell.types))
  }
  probs <- round(probs * 100)
  if (any(rowSums(probs) != 100)) {
    probs <- t(
      apply(
        X = probs, 
        MARGIN = 1,
        FUN = function(x) .setHundredLimit(x = x, index.ex = index.ex)
      )
    )  
  }
  colnames(probs) <- colnames(prob.matrix)
  return(probs)
}

################################################################################
######################## Simulate bulk RNA-seq samples #########################
################################################################################

#' Simulate training and test bulk RNA-seq profiles
#'
#' Simulate training and test bulk RNA-seq profiles using cell composition
#' matrices built by \code{\link{generateBulkCellMatrix}} function. Samples are
#' generated under the assumption that expression level of gene \eqn{i} in bulk
#' sample \eqn{j} is given by the sum of expression levels of cell types
#' \eqn{X_{ijk}} that compose them weighted by the proportions of these cell
#' types \eqn{k} in each sample. In practice, as described in Torroja and
#' Sanchez-Cabo, 2019, these profiles are generated by the summation of a number
#' of cells from different cell types determined by proportions from a known
#' cell composition matrix. The number of simulated bulk RNA-seq samples and the
#' number of cells that compose each sample are determined by
#' \code{\link{generateBulkCellMatrix}} (see Documentation) \strong{Note:} this
#' step can be avoid by using \code{on.the.fly} argument in
#' \code{\link{trainDigitalDLSorterModel}} function. See Documentation for more
#' information.
#'
#' \pkg{digitalDLSorteR} allows the use of HDF5 files as back-end for storing
#' the resulting data using \pkg{DelayedArray} and \pkg{HDF5Array} packages.
#' This functionality allows to work without keeping data loaded in RAM memory,
#' which could be of vital importance during some computationally heavy steps
#' such as neural network training in RAM limited machines. You must provide a
#' valid file path in \code{file.backend} argument to store the resulting file
#' with '.h5' extension. Data will be accessible from R without being loaded in
#' memory. This option slightly slows down execution times, since subsequent
#' transformations of data will be carried out by blocks instead of using all
#' data. We recommend this option according to the computational resources
#' available and the number of bulk samples that will be generated.
#'
#' Note that if you use \code{file.backend} argument with \code{block.processing
#' = FALSE}, all bulk profiles will be simulated in one step and, therefore,
#' allocated in RAM memory. Then, data will be written in HDF5 file. In order to
#' avoid collapsing RAM memory, single-cell profiles can be simulated and
#' written in HDF5 files by blocks of \code{block.size} size by setting
#' \code{block.processing = TRUE}.
#'
#' It is possible to avoid this step using \code{on.the.fly} argument in
#' \code{\link{trainDigitalDLSorterModel}} function. In this way, data is
#' generated 'on the fly' during the neural network training. See
#' \code{?\link{trainDigitalDLSorterModel}} for details.
#'
#' @param object \code{\linkS4class{DigitalDLSorter}} object with
#'   \code{single.cell.real}/\code{single.cell.simul} and \code{prob.cell.types}
#'   slots.
#' @param type.data Type of data to generate among \code{'train'}, \code{'test'}
#'   or \code{'both'} (the latter by default).
#' @param file.backend Valid file path to store simulated single-cell expression
#'   profiles as HDF5 file (\code{NULL} by default). If provided, data is stored
#'   in HDF5 files used as back-end by using \pkg{DelayedArray}, \pkg{HDF5Array}
#'   and \pkg{rhdf5} packages instead of loading data in RAM memory. This is
#'   suitable for situations where you have big amounts of data that cannot be
#'   allocated in memory. Note that operations on this data will be carried out
#'   by blocks (i.e subsets of determined size) which can lead to longer
#'   execution times.
#' @param compression.level The compression level used if \code{file.backend} is
#'   provided. It is an integer value between 0 (no compression) and 9 (highest
#'   and slowest compression). See
#'   \code{?\link[HDF5Array]{getHDF5DumpCompressionLevel}} from \pkg{HDF5Array}
#'   package for more information.
#' @param block.processing Boolean indicating if data should be simulated by
#'   blocks (only if \code{file.backend} is used, \code{FALSE} by default). This
#'   functionality is suitable for cases where is not possible to allocate data
#'   in memory and it leads to larger execution times.
#' @param block.size Only if \code{block.processing = TRUE}. Number of bulk
#'   expression profiles that will be simulated in each iteration during the
#'   process. Larger numbers resulting in more memory usage but lesser execution
#'   times. Set according to available computational resources (1000 by
#'   default).
#' @param chunk.dims Specifies dimensions that HDF5 chunk will have. If
#'   \code{NULL}, the default value is a vector of two items: the number of
#'   genes considered by \code{\linkS4class{DigitalDLSorter}} object during the
#'   simulation and only one sample in order to increase the read times in the
#'   following steps. Greater number of columns written in each chunk can lead
#'   to longer read times.
#' @param threads Number of threads used during the simulation of bulk samples
#'   (1 by default). Set according to computational resources and avoid it if
#'   \code{block.size} will be used.
#' @param verbose Show informative messages during the execution (\code{TRUE} by
#'   default).
#'
#' @return A \code{\linkS4class{DigitalDLSorter}} object with \code{bulk.simul}
#'   slot containing a list with one or two entries (depending on selected
#'   \code{type.data} argument): \code{'train'} and \code{'test'}. Each entry
#'   contains a \code{\link[SummarizedExperiment]{SummarizedExperiment}} object
#'   with simulated bulk samples in \code{assay} slot, sample names in
#'   \code{colData} slot and feature names in \code{rowData} slot.
#'
#' @export
#'
#' @seealso \code{\link{generateBulkCellMatrix}}
#'   \code{\linkS4class{ProbMatrixCellTypes}}
#'   \code{\link{trainDigitalDLSorterModel}}
#'
#' @examples
#' ## loading all data in memory
#' DDLSChungComp <- simBulkProfiles(
#'   DDLSChungComp,
#'   type.data = "both"
#' )
#'
#' \dontrun{
#' ## using HDF5 as backend
#' DDLSChungComp <- simBulkProfiles(
#'   DDLSChungComp,
#'   threads = 2,
#'   type.data = "both",
#'   file.backend = "DDLSChung.bulk.simul.h5"
#' )
#' }
#'
#' @references Fischer B, Smith M and Pau, G (2020). rhdf5: R Interface to HDF5.
#'   R package version 2.34.0.
#'
#'   Pagès H, Hickey wcfP and Lun A (2020). DelayedArray: A unified framework
#'   for working transparently with on-disk and in-memory array-like datasets. R
#'   package version 0.16.0.
#'
#'   Pagès H (2020). HDF5Array: HDF5 backend for DelayedArray objects. R package
#'   version 1.18.0.
#'   
simBulkProfiles <- function(
  object,
  type.data = "both",
  file.backend = NULL,
  compression.level = NULL,
  block.processing = FALSE,
  block.size = 1000,
  chunk.dims = NULL,
  threads = 1,
  verbose = TRUE
) {
  if (!is(object, "DigitalDLSorter")) {
    stop("The object provided is not of DigitalDLSorter class")
  } else if (is.null(single.cell.simul(object)) && 
             is.null(single.cell.real(object))) {
    stop("The are not single-cell profiles in DigitalDLSorter object")
  } else if (is.null(prob.cell.types(object))) {
    stop("'prob.cell.types' slot is empty")
  } else if (!any(type.data == c("train", "test", "both"))) {
    stop("'type.data' argument must be one of the next options: 'train', 'test' or 'both'")
  }
  if (!is.null(file.backend)) {
    if (file.exists(file.backend)) {
      stop("'file.backend' already exists. Please provide a correct file path")
    }
    if (is.null(compression.level)) {
      compression.level <- HDF5Array::getHDF5DumpCompressionLevel()
    } else {
      if (compression.level < 0 || compression.level > 9) {
        stop("'compression.level' must be an integer between 0 (no compression) ",
             "and 9 (highest and slowest compression). ")
      }
    }
  }
  if (threads <= 0) threads <- 1
  if (verbose) {
    message(paste("=== Set parallel environment to", threads, "thread(s)"))
  }
  if (type.data == "both") {
    if (!is.null(object@bulk.simul)) {
      warning("'bulk.simul' slot will be overwritten\n\n",
              call. = FALSE, immediate. = TRUE)
    }
    bulk.counts <- lapply(
      X = c("train", "test"),
      FUN = function(x) {
        if (verbose) {
          message(paste("\n=== Generating", x, "bulk samples:"))
        }
        .generateBulkProfiles(
          object = object,
          type.data = x,
          file.backend = file.backend,
          compression.level = compression.level,
          block.processing = block.processing,
          block.size = block.size,
          chunk.dims = chunk.dims,
          threads = threads,
          verbose = verbose
        )
      }
    )
    names(bulk.counts) <- c("train", "test")
    object@bulk.simul <- bulk.counts
  } else {
    if (!is.null(bulk.simul(object)) && type.data %in% names(bulk.simul(object))) {
      warning(paste(type.data, "data in 'bulk.simul' slot will be overwritten", 
                    "\n\n"),
              call. = FALSE, immediate. = TRUE)
    }
    if (verbose) {
      message(paste("\n=== Generating", type.data, "bulk samples:"))
    }
    bulk.counts <- .generateBulkProfiles(
      object = object,
      type.data = type.data,
      file.backend = file.backend,
      compression.level = compression.level,
      block.processing = block.processing,
      block.size = block.size,
      chunk.dims = chunk.dims,
      threads = threads,
      verbose = verbose
    )
    if (!is.null(bulk.simul(object))) {
      if (type.data %in% names(bulk.simul(object))) {
        bulk.simul(object, type.data) <- NULL
      }
      bulk.simul(object) <- c(bulk.simul(object), type.data = bulk.counts)
    } else {
      bulk.simul(object) <- list(bulk.counts)
      names(bulk.simul(object)) <- type.data
    }
  }
  if (verbose) message("\nDONE")
  return(object)
}

.generateBulkProfiles <- function(
  object,
  type.data,
  file.backend,
  compression.level,
  block.processing,
  block.size,
  chunk.dims,
  threads,
  verbose
) {
  sel.bulk.cells <- prob.cell.types(object, type.data) %>% cell.names()
  sel.bulk.cells <- sel.bulk.cells[sample(nrow(sel.bulk.cells)), ]
  if (!is.null(single.cell.simul(object))) {
    sufix.names <- unique(colData(single.cell.simul(object))$sufix)
  } else {
    sufix.names <- "_Simul"
  }
  pattern <- sufix.names
  if (block.processing && is.null(file.backend)) {
    stop("'block.processing' is only compatible to the use of HDF5 files ", 
         "as back-end ('file.backend' argument)")
  } else if (block.processing && !is.null(file.backend)) {
    n <- nrow(sel.bulk.cells)
    J <- nrow(assay(single.cell.real(object)))
    if (n < block.size) {
      block.size <- n
      warning("The number of simulated samples is lesser than 'block.size'. ",
              "Only one block will be performed.", 
              call. = FALSE, immediate. = TRUE)
    }
    if (is.null(chunk.dims) || length(chunk.dims) != 2) chunk.dims <- c(J, 1)
    if (!file.exists(file.backend)) rhdf5::h5createFile(file.backend)
    rhdf5::h5createDataset(
      file.backend, type.data, 
      dims = c(J, block.size), 
      maxdims = c(J, n), 
      chunk = chunk.dims,
      storage.mode = "double"
    )
    r.i <- 0
    ## iteration over cells 
    for (iter in seq(ceiling(n / block.size))) {
      if (verbose) message(paste("   - Writing block", iter))
      if ((block.size * iter) - n > 0) {
        dif <- block.size
        dif.2 <- (block.size * iter) - n
        block.size <- block.size - dif.2
      } else {
        dif <- block.size
      }
      sub.i <- seq(from = r.i + 1, to = r.i + block.size)
      r.i <- r.i + block.size
      if (threads == 1) {
        bulk.samples <- apply(
          X = sel.bulk.cells[sub.i, ],
          MARGIN = 1,
          FUN = .setBulk,
          object = object,
          pattern = pattern
        )
      } else {
        bulk.samples <- pbapply::pbapply(
          X = sel.bulk.cells[sub.i, ],
          MARGIN = 1,
          FUN = .setBulk,
          object = object,
          pattern = pattern,
          cl = threads
        )
      }
      if (iter == 1) {
        rhdf5::h5write(
          obj = bulk.samples, file = file.backend, 
          name = type.data, level = compression.level
        )
      } else {
        # check number of cells in the next loop
        rhdf5::h5set_extent(file.backend, type.data, dims = c(J, n))
        rhdf5::h5write(
          obj = bulk.samples, 
          file = file.backend, name = type.data, 
          index = list(seq(J), seq((dif * (iter - 1)) + 1, 
                                   (dif * (iter - 1)) + ncol(bulk.samples))),
          level = compression.level
        )
      }
    }
    rhdf5::H5close()
    # HDF5Array object for SingleCellExperiment class
    bulk.samples <- HDF5Array::HDF5Array(file = file.backend, name = type.data)
    dimnames(bulk.samples) <- list(rownames(assay(single.cell.real(object))), 
                                   rownames(sel.bulk.cells))
  } else if (!block.processing) {
    bulk.samples <- pbapply::pbapply(
      X = sel.bulk.cells,
      MARGIN = 1,
      FUN = .setBulk,
      object = object,
      pattern = pattern,
      cl = threads
    )
  }
  return(
    .createSEObject(
      counts = bulk.samples,
      samples.metadata = prob.cell.types(object, type.data)@prob.matrix[
        rownames(sel.bulk.cells), ],
      genes.metadata = rownames(assay(single.cell.real(object))),
      file.backend = file.backend,
      compression.level = compression.level,
      block.processing = block.processing,
      type.data = type.data,
      verbose = verbose
    )
  )
}

.createSEObject <- function(
  counts, 
  samples.metadata, 
  genes.metadata,
  file.backend,
  compression.level,
  block.processing,
  type.data,
  verbose
) {
  # could be a check of counts class -> if (is(counts, "HDF5Array"))
  if (!is.null(file.backend) && !block.processing) {
    counts <- .useH5backend(
      counts = counts,
      file.backend = file.backend,
      compression.level = compression.level,
      group = type.data,
      sparse = FALSE,
      verbose = verbose
    )
  }
  return(
    SummarizedExperiment::SummarizedExperiment(
      assays = list(counts = counts),
      colData = samples.metadata,
      rowData = genes.metadata
    )
  )
}

.setBulk <- function(x, object, pattern) {
  sep.b <- grepl(pattern = pattern, x = x)
  if (any(sep.b)) {
    cols.sim <- match(x[sep.b], colnames(single.cell.simul(object))) %>% sort()
    cols.real <- match(x[!sep.b], colnames(single.cell.real(object))) %>% sort()
    sim.counts <- as.matrix(assay(single.cell.simul(object))[, cols.sim])
    real.counts <- as.matrix(assay(single.cell.real(object))[, cols.real])
    counts <- .mergeMatrices(x = real.counts, y = sim.counts) # merge matrices
  } else if (all(sep.b)) {
    cols <- match(x[sep.b], colnames(single.cell.simul(object))) %>% sort()
    counts <- as.matrix(assay(single.cell.simul(object))[, cols])
  } else {
    cols <- match(x, colnames(single.cell.real(object))) %>% sort()
    counts <- as.matrix(assay(single.cell.real(object))[, cols])
  }
  return(rowSums(edgeR::cpm.default(counts)))  
}
